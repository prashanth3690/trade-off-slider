<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trade‑Off Slider</title>
    <!-- Import a modern geometric font reminiscent of Bauhaus -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
    <style>
      /* Base typography and layout */
      body {
        margin: 0;
        padding: 40px;
        font-family: 'Montserrat', sans-serif;
        background-color: #f1f1f1;
        color: #2a2a2a;
        line-height: 1.5;
      }
      h1 {
        font-size: 32px;
        font-weight: 600;
        margin-bottom: 10px;
        color: #0e0e0e;
      }
      p {
        font-size: 16px;
        max-width: 700px;
        margin-bottom: 30px;
        color: #555;
      }
      /* Container for all slider rows */
      #slider-container {
        display: flex;
        flex-direction: column;
        gap: 20px;
        max-width: 700px;
      }
      /* Each row styled like a modern card */
      .slider-row {
        display: flex;
        align-items: center;
        padding: 16px;
        background-color: #ffffff;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      /* Row label input styling */
      .slider-row .row-label-input {
        flex: 1;
        margin-right: 20px;
        font-size: 16px;
        font-weight: 600;
        border: none;
        border-bottom: 2px solid #ccc;
        background-color: transparent;
        outline: none;
        padding: 4px 0;
        transition: border-color 0.2s ease;
      }
      .slider-row .row-label-input:focus {
        border-color: #E63946; /* red accent */
      }
      /* Range slider styling */
      .slider-row input[type="range"] {
        -webkit-appearance: none;
        width: 100%;
        height: 6px;
        /* Custom property to control the fill percentage of the track */
        --track-fill: 0%;
        background: transparent;
        border-radius: 3px;
        outline: none;
        margin-right: 20px;
        flex: 3;
      }
      .slider-row input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #E63946; /* red accent */
        border: 2px solid #2a2a2a;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      .slider-row input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #E63946;
        border: 2px solid #2a2a2a;
        cursor: pointer;
      }
      .slider-row input[type="range"]::-webkit-slider-runnable-track {
        height: 6px;
        border-radius: 3px;
        background: linear-gradient(to right, #457B9D 0%, #457B9D var(--track-fill), #e0e0e0 var(--track-fill), #e0e0e0 100%);
      }
      .slider-row input[type="range"]::-moz-range-track {
        height: 6px;
        border-radius: 3px;
        background: linear-gradient(to right, #457B9D 0%, #457B9D var(--track-fill), #e0e0e0 var(--track-fill), #e0e0e0 100%);
      }
      /* Value display styling */
      .slider-row .value-display {
        width: 30px;
        text-align: right;
        font-size: 16px;
        font-weight: 600;
        color: #E9C46A; /* golden yellow accent */
      }
      /* Add row button styling */
      #add-row-btn {
        margin-top: 30px;
        padding: 12px 30px;
        background-color: #457B9D; /* blue accent */
        color: #ffffff;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 600;
        letter-spacing: 0.5px;
        transition: background-color 0.2s ease, transform 0.1s ease;
      }
      #add-row-btn:hover:not(:disabled) {
        background-color: #356079;
        transform: translateY(-2px);
      }
      #add-row-btn:active:not(:disabled) {
        transform: translateY(0);
      }
      #add-row-btn:disabled {
        background-color: #a5c8e2;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <h1>Prioritization Trade‑Off Sliders</h1>
    <p>Adjust the sliders to distribute priorities. Each slider has five levels (0–5) regardless of the number of rows. The total points available are three points per row—for example, with four rows you have 12 points to allocate. When you change one slider, the others will adjust so that the sum never exceeds your available points.</p>
    <div id="slider-container"></div>
    <button id="add-row-btn">Add Row</button>

    <script>
      (function() {
        // Maximum number of rows allowed.
        const MAX_ROWS = 6;
        // Starting number of rows.
        let currentRows = 4;

        const sliderContainer = document.getElementById('slider-container');
        const addRowBtn = document.getElementById('add-row-btn');

        // Initialize the slider rows.
        function init() {
          for (let i = 0; i < currentRows; i++) {
            addSliderRow();
          }
          updateSliderMax();
        }

        // Create and append a new slider row.
        function addSliderRow() {
          const rowIndex = sliderContainer.children.length + 1;
          const row = document.createElement('div');
          row.className = 'slider-row';

          // Editable label for the row
          const labelInput = document.createElement('input');
          labelInput.type = 'text';
          labelInput.value = `Row ${rowIndex}`;
          labelInput.className = 'row-label-input';
          labelInput.style.flex = '1';
          labelInput.style.marginRight = '15px';
          labelInput.style.fontWeight = 'bold';
          row.appendChild(labelInput);

          // Slider input (always 5 levels)
          const slider = document.createElement('input');
          slider.type = 'range';
          slider.min = 0;
          slider.max = 5;
          slider.value = 0;
          slider.addEventListener('input', onSliderChange);
          row.appendChild(slider);

          // Value display
          const valueDisplay = document.createElement('div');
          valueDisplay.className = 'value-display';
          valueDisplay.textContent = slider.value;
          row.appendChild(valueDisplay);

          sliderContainer.appendChild(row);

          // Set data attributes for easier handling.
          row.sliderElement = slider;
          row.valueDisplay = valueDisplay;

          // Initialize slider fill background
          updateSliderFill(slider);
        }

        // Update the max attribute for all sliders to match the current number of rows.
        function updateSliderMax() {
          // Sliders now always have a fixed maximum of 5.
          const rows = sliderContainer.children;
          for (let i = 0; i < rows.length; i++) {
            const slider = rows[i].sliderElement;
            slider.max = 5;
            if (parseInt(slider.value, 10) > 5) {
              slider.value = 5;
              rows[i].valueDisplay.textContent = slider.value;
            }
            // Update slider fill based on its current value
            updateSliderFill(slider);
          }
          // After any clamping, ensure total does not exceed the new maximum points.
          enforceTotalLimit();
        }

        // Event handler when any slider value changes.
        function onSliderChange(event) {
          const changedSlider = event.target;
          const changedValue = parseInt(changedSlider.value, 10);
          const rows = sliderContainer.children;

          // Update the displayed value for the changed slider.
          for (let i = 0; i < rows.length; i++) {
            if (rows[i].sliderElement === changedSlider) {
              rows[i].valueDisplay.textContent = changedValue;
              break;
            }
          }

          // Update the fill of the changed slider
          updateSliderFill(changedSlider);

          // Enforce the total limit after this change.
          enforceTotalLimit(changedSlider);
        }

        // Ensure that the sum of all slider values does not exceed the maximum allowed points.
        // If a changedSlider is provided (the slider the user just interacted with),
        // its value will be reduced (if necessary) to enforce the limit. If no slider
        // is specified (such as during initialization), other sliders will be adjusted.
        function enforceTotalLimit(changedSlider = null) {
          const rows = sliderContainer.children;
          // Maximum points available = number of rows * 3
          const maxPoints = rows.length * 3;

          // Compute current total sum
          let total = 0;
          for (let i = 0; i < rows.length; i++) {
            total += parseInt(rows[i].sliderElement.value, 10);
          }
          // If total is within limit, nothing to adjust.
          if (total <= maxPoints) return;

          // When a specific slider was changed, adjust that slider downward to stay within the limit.
          if (changedSlider) {
            // Compute the sum of all other sliders
            let sumOther = 0;
            for (let i = 0; i < rows.length; i++) {
              const slider = rows[i].sliderElement;
              if (slider !== changedSlider) {
                sumOther += parseInt(slider.value, 10);
              }
            }
            // Determine the maximum value the changed slider can take
            let allowed = maxPoints - sumOther;
            if (allowed < 0) allowed = 0;
            // Clamp the changed slider's value to the allowed value
            const newValue = Math.min(parseInt(changedSlider.value, 10), allowed);
            if (newValue !== parseInt(changedSlider.value, 10)) {
              changedSlider.value = newValue;
              // Update the associated display
              for (let i = 0; i < rows.length; i++) {
                if (rows[i].sliderElement === changedSlider) {
                  rows[i].valueDisplay.textContent = newValue;
                  break;
                }
              }
              // Update the slider fill after clamping
              updateSliderFill(changedSlider);
            }
            return;
          }

          // If no specific slider is provided, reduce other sliders to meet the limit (fallback behaviour)
          // This occurs during initialization or when adding rows.
          let excess = total - maxPoints;
          for (let i = 0; i < rows.length; i++) {
            const slider = rows[i].sliderElement;
            const value = parseInt(slider.value, 10);
            if (value > 0) {
              const reduction = Math.min(value, excess);
              slider.value = value - reduction;
              rows[i].valueDisplay.textContent = slider.value;
              excess -= reduction;
              // Update fill for each modified slider
              updateSliderFill(slider);
              if (excess <= 0) break;
            }
          }
        }

        // Add row button click handler
        addRowBtn.addEventListener('click', function() {
          if (sliderContainer.children.length < MAX_ROWS) {
            addSliderRow();
            updateSliderMax();
          }
          // Disable button if maximum rows reached
          if (sliderContainer.children.length >= MAX_ROWS) {
            addRowBtn.disabled = true;
          }
        });

        // Initialize the page
        init();

        /**
         * Update the background fill of a range input to visually represent its value.
         * Uses a gradient where the filled portion is the Bauhaus blue color and the remainder
         * is a light gray. This function should be called whenever a slider's value changes
         * or when values are clamped.
         * @param {HTMLInputElement} slider The range input element to update.
         */
        function updateSliderFill(slider) {
          const max = parseInt(slider.max, 10);
          const value = parseInt(slider.value, 10);
          const percent = max === 0 ? 0 : (value / max) * 100;
          // Construct gradient: blue for filled, gray for remaining
          slider.style.setProperty('--track-fill', `${percent}%`);
        }
      })();
    </script>
  </body>
</html>
